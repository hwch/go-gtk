package gtk

/*
#cgo pkg-config: gobject-2.0
#include <stdlib.h>
#include <stdint.h>
#include <glib-object.h>
#include <string.h>

#include "gobj.h"

extern uint32_t g_quark_from_string(const char*);
extern void g_object_set_qdata(GObject*, uint32_t, void*);

*/
import "C"
import "unsafe"
import "runtime"
import "reflect"
import "sync"

type Type C.GType

type _Value__data__union struct {
        _data [8]byte
}

type Value struct {
        GType   Type
        Data    [2]_Value__data__union
}

type Object struct {
        C unsafe.Pointer
}
type Quark uint32

// Every GObject generated by this generator implements this interface
// and it must work even if the receiver is a nil value
type StaticTyper interface {
        GetStaticType() Type
}

// blacklisted: InterfaceInitFunc (callback)
type ObjectLike interface {
        InheritedFromGObject() *C.GObject
}

//--------------------------------------------------------------
// FinalizerQueue
//--------------------------------------------------------------

type finalizer_item struct {
        ptr       unsafe.Pointer
        finalizer func(unsafe.Pointer)
}

type fqueue_type struct {
        sync.Mutex
        queue      []finalizer_item
        exec_queue []finalizer_item
        tid        uint32
}

type holder_key [2]unsafe.Pointer
type holder_type map[holder_key]int

// we use this one to store Go's representation of the GObject
// as user data in that GObject once it was allocated. For the
// sake of avoiding allocations.
var go_repr Quark
var Holder holder_type
var FQueue fqueue_type
var (
        Interface   Type
        Char        Type
        UChar       Type
        Boolean     Type
        Int         Type
        UInt        Type
        Long        Type
        ULong       Type
        Int64       Type
        UInt64      Type
        Enum        Type
        Flags       Type
        Float       Type
        Double      Type
        String      Type
        Pointer     Type
        Boxed       Type
        Param       Type
        GObject     Type
        GType       Type
        Variant     Type
        GoInterface Type
)

func init() {
        // C.g_type_init()

        Interface = Type(C._g_type_interface())
        Char = Type(C._g_type_char())
        UChar = Type(C._g_type_uchar())
        Boolean = Type(C._g_type_boolean())
        Int = Type(C._g_type_int())
        UInt = Type(C._g_type_uint())
        Long = Type(C._g_type_long())
        ULong = Type(C._g_type_ulong())
        Int64 = Type(C._g_type_int64())
        UInt64 = Type(C._g_type_uint64())
        Enum = Type(C._g_type_enum())
        Flags = Type(C._g_type_flags())
        Float = Type(C._g_type_float())
        Double = Type(C._g_type_double())
        String = Type(C._g_type_string())
        Pointer = Type(C._g_type_pointer())
        Boxed = Type(C._g_type_boxed())
        Param = Type(C._g_type_param())
        GObject = Type(C._g_type_object())
        GType = Type(C._g_type_gtype())
        Variant = Type(C._g_type_variant())
        GoInterface = Type(C._g_type_go_interface())
        // Holder------------------
        Holder = holder_type(make(map[holder_key]int))

        go_repr = NewQuarkFromString("go-representation")
}

const alot = 999999

func _GoStringToGString(x string) *C.char {
        if x == "\x00" {
                return nil
        }
        return C.CString(x)
}

func _GoBoolToCBool(x bool) C.int {
        if x {
                return 1
        }
        return 0
}

func _CInterfaceToGoInterface(iface [2]unsafe.Pointer) interface{} {
        return *(*interface{})(unsafe.Pointer(&iface))
}

func _GoInterfaceToCInterface(iface interface{}) *unsafe.Pointer {
        return (*unsafe.Pointer)(unsafe.Pointer(&iface))
}

//export _GObject_go_callback_cleanup
func _GObject_go_callback_cleanup(gofunc unsafe.Pointer) {
        Holder.Release(gofunc)
}

//--------------------------------------------------------------
// Holder
//--------------------------------------------------------------
// holy crap, what am I doing here..

func (this holder_type) Grab(x interface{}) {
        if x == nil {
                return
        }

        key := *(*holder_key)(unsafe.Pointer(&x))
        count := this[key]
        this[key] = count + 1
}

func (this holder_type) Release(x interface{}) {
        if x == nil {
                return
        }

        key := *(*holder_key)(unsafe.Pointer(&x))
        count := this[key]
        if count <= 1 {
                delete(this, key)
        } else {
                this[key] = count - 1
        }
}

//--------------------------------------------------------------
// Closures
//--------------------------------------------------------------

//export gGoclosureFinalizeGo
func gGoclosureFinalizeGo(goclosure_up unsafe.Pointer) {
        goclosure := (*C.GGoClosure)(goclosure_up)
        clo := *(*interface{})(C.gGoclosureGetFunc(goclosure))
        recv := *(*interface{})(C.gGoclosureGetRecv(goclosure))
        Holder.Release(clo)
        Holder.Release(recv)
}

//export gGoclosureMarshalGo
func gGoclosureMarshalGo(goclosure_up, ret_up unsafe.Pointer, nargs int32, args_up unsafe.Pointer) {
        var callargs [20]reflect.Value
        var recv reflect.Value
        goclosure := (*C.GGoClosure)(goclosure_up)
        ret := (*Value)(ret_up)
        args := (*(*[alot]Value)(args_up))[:nargs]
        f := reflect.ValueOf(*(*interface{})(C.gGoclosureGetFunc(goclosure)))
        ft := f.Type()
        callargsn := ft.NumIn()

        recvi := *(*interface{})(C.gGoclosureGetRecv(goclosure))
        if recvi != nil {
                recv = reflect.ValueOf(recvi)
        }

        if callargsn >= 20 {
                panic("too many arguments in a closure")
        }

        for i, n := 0, callargsn; i < n; i++ {
                idx := i
                if recvi != nil {
                        idx--
                        if i == 0 {
                                callargs[i] = recv
                                continue
                        }
                }

                in := ft.In(i)

                // use default value, if there is not enough args
                if len(args) <= idx {
                        callargs[i] = reflect.New(in).Elem()
                        continue
                }

                v := args[idx].GetGoValue(in)
                callargs[i] = v
        }

        out := f.Call(callargs[:callargsn])
        if len(out) == 1 {
                ret.SetGoValue(out[0])
        }
}

//--------------------------------------------------------------
// Value
//--------------------------------------------------------------

func (this *Value) asC() *C.GValue {
        return (*C.GValue)(unsafe.Pointer(this))
}

// g_value_init
func (this *Value) Init(t Type) {
        C.g_value_init(this.asC(), t.asC())
}

// g_value_copy
func (this *Value) Set(src *Value) {
        C.g_value_copy(src.asC(), this.asC())
}

// g_value_reset
func (this *Value) Reset() {
        C.g_value_reset(this.asC())
}

// g_value_unset
func (this *Value) Unset() {
        C.g_value_unset(this.asC())
}

// G_VALUE_TYPE
func (this *Value) GetType() Type {
        return Type(C._g_value_type(this.asC()))
}

// g_value_type_compatible
func ValueTypeCompatible(src, dst Type) bool {
        return C.g_value_type_compatible(src.asC(), dst.asC()) != 0
}

// g_value_type_transformable
func ValueTypeTransformable(src, dst Type) bool {
        return C.g_value_type_transformable(src.asC(), dst.asC()) != 0
}

// g_value_transform
func (this *Value) Transform(src *Value) bool {
        return C.g_value_transform(src.asC(), this.asC()) != 0
}

// g_value_get_boolean
func (this *Value) GetBool() bool {
        return C.g_value_get_boolean(this.asC()) != 0
}

// g_value_set_boolean
func (this *Value) SetBool(v bool) {
        C.g_value_set_boolean(this.asC(), C.gboolean(_GoBoolToCBool(v)))
}

// g_value_get_int64
func (this *Value) GetInt() int64 {
        return int64(C.g_value_get_int64(this.asC()))
}

// g_value_set_int64
func (this *Value) SetInt(v int64) {
        C.g_value_set_int64(this.asC(), C.gint64(v))
}

// g_value_get_uint64
func (this *Value) GetUint() uint64 {
        return uint64(C.g_value_get_uint64(this.asC()))
}

// g_value_set_uint64
func (this *Value) SetUint(v uint64) {
        C.g_value_set_uint64(this.asC(), C.guint64(v))
}

// g_value_get_double
func (this *Value) GetFloat() float64 {
        return float64(C.g_value_get_double(this.asC()))
}

// g_value_set_double
func (this *Value) SetFloat(v float64) {
        C.g_value_set_double(this.asC(), C.gdouble(v))
}

// g_value_get_string
func (this *Value) GetString() string {
        return C.GoString((*C.char)(C.g_value_get_string(this.asC())))
}

// g_value_take_string
func (this *Value) SetString(v string) {
        cstr := _GString(v)
        C.g_value_take_string(this.asC(), cstr)
        // not freeing, because GValue takes the ownership
}

// g_value_get_object
func (this *Value) GetObject() unsafe.Pointer {
        return unsafe.Pointer(C.g_value_get_object(this.asC()))
}

// g_value_set_object
func (this *Value) SetObject(x unsafe.Pointer) {
        C.g_value_set_object(this.asC(), C.gpointer(x))
}

// g_value_get_boxed
func (this *Value) GetBoxed() unsafe.Pointer {
        return unsafe.Pointer(C.g_value_get_boxed(this.asC()))
}

// g_value_take_boxed
func (this *Value) SetBoxed(x unsafe.Pointer) {
        C.g_value_take_boxed(this.asC(), C.gconstpointer(x))
}

func (this *Value) GetBoxedInterface() interface{} {
        return *(*interface{})(C.g_value_get_boxed(this.asC()))
}

func (this *Value) SetBoxedInterface(x interface{}) {
        Holder.Grab(x)
        newboxed := C.malloc(C.size_t(unsafe.Sizeof([2]unsafe.Pointer{})))
        C.memcpy(newboxed, unsafe.Pointer(&x), C.size_t(unsafe.Sizeof([2]unsafe.Pointer{})))
        C.g_value_take_boxed(this.asC(), C.gconstpointer(newboxed))
}

//--------------------------------------------------------------
// A giant glue for connecting GType and Go's reflection
//--------------------------------------------------------------

var statictyper = reflect.TypeOf((*StaticTyper)(nil)).Elem()
var objectlike = reflect.TypeOf((*ObjectLike)(nil)).Elem()

func (this *Value) SetGoValue(v reflect.Value) {
        valuetype := this.GetType()
        var src Value

        if valuetype == GoInterface {
                // special case
                this.SetBoxedInterface(v.Interface())
                return
        }

        transform := func() {
                ok := this.Transform(&src)
                if !ok {
                        panic("Go value (" + v.Type().String() + ") is not transformable to " + valuetype.String())
                }
        }

        switch v.Kind() {
        case reflect.Bool:
                src.Init(Boolean)
                src.SetBool(v.Bool())
                transform()
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
                src.Init(Int64)
                src.SetInt(v.Int())
                transform()
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
                src.Init(UInt64)
                src.SetUint(v.Uint())
                transform()
        case reflect.Float32, reflect.Float64:
                src.Init(Double)
                src.SetFloat(v.Float())
                transform()
        case reflect.String:
                src.Init(String)
                src.SetString(v.String())
                transform()
                src.Unset()
        case reflect.Ptr:
                gotype := v.Type()
                src.Init(GObject)
                if gotype.Implements(objectlike) {
                        obj, ok := v.Interface().(ObjectLike)
                        if !ok {
                                panic(gotype.String() + " is not transformable to GValue")
                        }

                        src.SetObject(unsafe.Pointer(obj.InheritedFromGObject()))
                        transform()
                }
                src.Unset()
        }
}

var CairoMarshaler func(*Value, reflect.Type) (reflect.Value, bool)

func (this *Value) GetGoValue(t reflect.Type) reflect.Value {
        var out reflect.Value
        var dst Value

        if this.GetType() == GoInterface {
                return reflect.ValueOf(this.GetBoxedInterface())
        }

        transform := func() {
                ok := dst.Transform(this)
                if !ok {
                        panic("GValue is not transformable to " + t.String())
                }
        }

        switch t.Kind() {
        case reflect.Bool:
                dst.Init(Boolean)
                transform()
                out = reflect.New(t).Elem()
                out.SetBool(dst.GetBool())
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
                dst.Init(Int64)
                transform()
                out = reflect.New(t).Elem()
                out.SetInt(dst.GetInt())
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
                dst.Init(UInt64)
                transform()
                out = reflect.New(t).Elem()
                out.SetUint(dst.GetUint())
        case reflect.Float32, reflect.Float64:
                dst.Init(Double)
                transform()
                out = reflect.New(t).Elem()
                out.SetFloat(dst.GetFloat())
        case reflect.String:
                dst.Init(String)
                transform()
                out = reflect.New(t).Elem()
                out.SetString(dst.GetString())
                dst.Unset() // need to clean up in this case
        case reflect.Ptr:
                if t.Implements(objectlike) {
                        // at this point we're sure that this is a pointer to the ObjectLike
                        out = reflect.New(t)
                        st, ok := out.Elem().Interface().(StaticTyper)
                        if !ok {
                                panic("ObjectLike type must implement StaticTyper as well")
                        }
                        dst.Init(st.GetStaticType())
                        transform()
                        *(*unsafe.Pointer)(unsafe.Pointer(out.Pointer())) = ObjectWrap(dst.GetObject(), true)
                        dst.Unset()
                        out = out.Elem()
                } else {
                        // cairo marshaler hook
                        if CairoMarshaler != nil {
                                var ok bool
                                out, ok = CairoMarshaler(this, t)
                                if ok {
                                        break
                                }
                        }

                        // must be a struct then
                        out = reflect.New(t)
                        *(*unsafe.Pointer)(unsafe.Pointer(out.Pointer())) = this.GetBoxed()
                        out = out.Elem()
                }
        }
        return out
}

func (this *Value) SetGoInterface(v interface{}) {
        this.SetGoValue(reflect.ValueOf(v))
}

func (this *Value) GetGoInterface(v interface{}) {
        vp := reflect.ValueOf(v)
        if vp.Kind() != reflect.Ptr {
                panic("a pointer to value is expected for Value.GetGoInterface")
        }
        vp.Elem().Set(this.GetGoValue(vp.Type().Elem()))
}

//--------------------------------------------------------------
// Type
//--------------------------------------------------------------

func (this Type) IsA(other Type) bool {
        return C.g_type_is_a(C.GType(this), C.GType(other)) != 0
}

func (this Type) String() string {
        cname := C.g_type_name(C.GType(this))
        if cname == nil {
                return ""
        }
        return C.GoString((*C.char)(cname))
}

func (this Type) asC() C.GType {
        return C.GType(this)
}

//--------------------------------------------------------------
// Go Interface boxed type
//--------------------------------------------------------------

//export gGoInterfaceCopyGo
func gGoInterfaceCopyGo(boxed unsafe.Pointer) unsafe.Pointer {
        Holder.Grab(*(*interface{})(boxed))
        newboxed := C.malloc(C.size_t(unsafe.Sizeof([2]unsafe.Pointer{})))
        C.memcpy(newboxed, boxed, C.size_t(unsafe.Sizeof([2]unsafe.Pointer{})))
        return newboxed
}

//export gGoInterfaceFreeGo
func gGoInterfaceFreeGo(boxed unsafe.Pointer) {
        Holder.Release(*(*interface{})(boxed))
        C.free(boxed)
}

func ObjectWrap(c unsafe.Pointer, grab bool) unsafe.Pointer {
        if c == nil {
                return nil
        }
        obj := (*Object)(C.g_object_get_qdata((*C.GObject)(c), C.GQuark(go_repr)))
        if obj != nil {
                return unsafe.Pointer(obj)
        }
        obj = &Object{c}
        if grab {
                C.g_object_ref_sink(C.gpointer(obj.C))
        }
        setObjectFinalizer(obj)
        C.g_object_set_qdata((*C.GObject)(obj.C),
                C.GQuark(go_repr), unsafe.Pointer(obj))
        return unsafe.Pointer(obj)
}

func setObjectFinalizer(obj *Object) {
        runtime.SetFinalizer(obj, objectFinalizer)
}

//--------------------------------------------------------------
// Quark
//
// TODO: probably it's a temporary place for this, quarks are
// from glib
//--------------------------------------------------------------

func NewQuarkFromString(s string) Quark {
        cs := _GString(s)
        quark := C.g_quark_from_string(cs)
        _GFree(unsafe.Pointer(cs))
        return Quark(quark)
}

//--------------------------------------------------------------
// Object
//--------------------------------------------------------------
func objectFinalizer(obj *Object) {
        if FQueue.Push(unsafe.Pointer(obj), objectFinalizer2) {
                return
        }
        C.g_object_set_qdata((*C.GObject)(obj.C), C.GQuark(go_repr), nil)
        C.g_object_unref(C.gpointer(obj.C))
}

func objectFinalizer2(objc unsafe.Pointer) {
        obj := (*Object)(objc)
        C.g_object_set_qdata((*C.GObject)(obj.C), C.GQuark(go_repr), nil)
        C.g_object_unref(C.gpointer(obj.C))
}

// returns true if the item was enqueued, thread safe
func (this *fqueue_type) Push(ptr unsafe.Pointer, finalizer func(unsafe.Pointer)) bool {
        this.Lock()
        if this.queue != nil {
                this.queue = append(this.queue, finalizer_item{ptr, finalizer})
                this.Unlock()
                return true
        }
        this.Unlock()
        return false
}
